# -*- coding: utf-8 -*-
"""TSP/Dijkstrak.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oVf44mGnTIcsaygDc85QgxBMa_Zgs7Ne
"""

import networkx as nx
import time
import random

def tsp(graph, start):
    def node_to_int(node):
        return ord(node) - ord('A')

    def int_to_node(num):
        return chr(num + ord('A'))

    n = graph.number_of_nodes()
    visited = [False] * n
    path = [start]
    visited[node_to_int(start)] = True
    total_weight = 0
    start_time = time.time()

    def tsp_util(curr):
        nonlocal total_weight
        min_weight = float('inf')
        next_node = None
        for neighbor in graph.neighbors(int_to_node(curr)):
            weight = graph[int_to_node(curr)][neighbor]['weight']
            if not visited[node_to_int(neighbor)] and weight < min_weight:
                min_weight = weight
                next_node = neighbor
        if next_node is not None:
            path.append(next_node)
            visited[node_to_int(next_node)] = True
            total_weight += min_weight
            tsp_util(node_to_int(next_node))

    tsp_util(node_to_int(start))
    end_time = time.time()
    return path, total_weight, end_time - start_time

def dijkstra(graph, start, end):
    dist = {}
    prev = {}
    unvisited = set(graph.nodes())
    start_time = time.time()

    def node_to_int(node):
        return ord(node) - ord('A')

    def int_to_node(num):
        return chr(num + ord('A'))

    for node in graph.nodes():
        dist[node] = float('inf')
    dist[start] = 0

    while unvisited:
        min_dist = float('inf')
        curr = None
        for node in unvisited:
            if dist[node] < min_dist:
                min_dist = dist[node]
                curr = node
        unvisited.remove(curr)

        for neighbor in graph.neighbors(curr):
            weight = graph[curr][neighbor]['weight']
            alt = dist[curr] + weight
            if alt < dist[neighbor]:
                dist[neighbor] = alt
                prev[neighbor] = curr

    end_time = time.time()
    path = []
    curr = end
    while curr != start:
        path.append(curr)
        curr = prev[curr]
    path.append(start)
    path.reverse()
    return path, dist[end], end_time - start_time

def print_iterations(path):
    print("Iterasi:")
    for i, node in enumerate(path):
        print(f"Iterasi {i+1}: {node}")
    print()

def print_computation_time(time):
    print(f"Waktu Perhitungan: {time:.6f} detik")

def print_shortest_path(path, weight):
    print("Jalur Terpendek:")
    print(" -> ".join(path))
    print(f"Total Bobot: {weight}\n")

def generate_random_graph(n):
    graph = nx.Graph()
    nodes = [chr(i + ord('A')) for i in range(n)]
    for i in range(n):
        for j in range(i + 1, n):
            weight = random.randint(1, 100)
            graph.add_edge(nodes[i], nodes[j], weight=weight)
    return graph

def analyze_tsp(graph, start_node):
    print("Analisis Algoritma TSP:")
    print(f"Jumlah Node: {graph.number_of_nodes()}")
    print(f"Node Awal: {start_node}")

    # Worst Case
    print("\nWorst Case:")
    path, weight, time_taken = tsp(graph, start_node)
    print_iterations(path)
    print_computation_time(time_taken)
    print_shortest_path(path, weight)

    # Best Case
    print("\nBest Case:")
    path, weight, time_taken = tsp(graph, start_node)
    print_iterations(path)
    print_computation_time(time_taken)
    print_shortest_path(path, weight)

    # Average Case
    print("\nAverage Case:")
    total_time = 0
    total_weight = 0
    num_trials = 100
    for _ in range(num_trials):
        path, weight, time_taken = tsp(graph, start_node)
        total_time += time_taken
        total_weight += weight
    average_time = total_time / num_trials
    average_weight = total_weight / num_trials
    print_computation_time(average_time)
    print(f"Rata-rata Bobot: {average_weight}\n")

def analyze_dijkstra(graph, start_node, end_node):
    print("Analisis Algoritma Dijkstra:")
    print(f"Jumlah Node: {graph.number_of_nodes()}")
    print(f"Node Awal: {start_node}")
    print(f"Node Akhir: {end_node}")

    # Worst Case
    print("\nWorst Case:")
    path, weight, time_taken = dijkstra(graph, start_node, end_node)
    print_iterations(path)
    print_computation_time(time_taken)
    print_shortest_path(path, weight)

    # Best Case
    print("\nBest Case:")
    path, weight, time_taken = dijkstra(graph, start_node, end_node)
    print_iterations(path)
    print_computation_time(time_taken)
    print_shortest_path(path, weight)

    # Average Case
    print("\nAverage Case:")
    total_time = 0
    total_weight = 0
    num_trials = 100
    for _ in range(num_trials):
        path, weight, time_taken = dijkstra(graph, start_node, end_node)
        total_time += time_taken
        total_weight += weight
    average_time = total_time / num_trials
    average_weight = total_weight / num_trials
    print_computation_time(average_time)
    print(f"Rata-rata Bobot: {average_weight}\n")

def main():
    graph = nx.Graph()
    graph.add_edges_from([
        ('A', 'B', {'weight': 12}),
        ('A', 'C', {'weight': 10}),
        ('A', 'G', {'weight': 12}),
        ('B', 'A', {'weight': 12}),
        ('B', 'C', {'weight': 8}),
        ('B', 'D', {'weight': 12}),
        ('C', 'A', {'weight': 10}),
        ('C', 'B', {'weight': 8}),
        ('C', 'D', {'weight': 11}),
        ('C', 'E', {'weight': 3}),
        ('C', 'G', {'weight': 9}),
        ('D', 'C', {'weight': 11}),
        ('D', 'E', {'weight': 11}),
        ('D', 'F', {'weight': 10}),
        ('E', 'C', {'weight': 3}),
        ('E', 'D', {'weight': 11}),
        ('E', 'F', {'weight': 6}),
        ('E', 'G', {'weight': 7}),
        ('F', 'D', {'weight': 10}),
        ('F', 'E', {'weight': 6}),
        ('F', 'G', {'weight': 9}),
        ('G', 'A', {'weight': 12}),
        ('G', 'C', {'weight': 9}),
        ('G', 'E', {'weight': 7}),
        ('G', 'F', {'weight': 9})
    ])

    print("NUR FADILLAH_F55121047")
    print("1. TSP ")
    print("2. Dijkstra")

    choice = int(input("Pilih perhitungan yang ingin anda lakukan (1/2): "))

    if choice == 1:
        start_node = input("Pilih node Awal : ")
        analyze_tsp(graph, start_node)
    elif choice == 2:
        start_node = input("Pilih node Awal : ")
        end_node = input("Pilih node Akhir : ")
        analyze_dijkstra(graph, start_node, end_node)
    else:
        print("Pilihan tidak valid. Silakan coba lagi.")

    continue_choice = input("Apakah Anda ingin melanjutkan perhitungan? (YA/TIDAK): ")

    while continue_choice.lower() == "ya":
        print("NUR FADILLAH_F55121047")
        print("1. TSP")
        print("2. Dijkstra")

        choice = int(input("Pilih perhitungan yang ingin anda lakukan (1/2): "))

        if choice == 1:
            start_node = input("Pilih node Awal : ")
            analyze_tsp(graph, start_node)
        elif choice == 2:
            start_node = input("Pilih node Awal : ")
            end_node = input("Pilih node Akhir : ")
            analyze_dijkstra(graph, start_node, end_node)
        else:
            print("Pilihan tidak valid. Silakan coba lagi.")

        print("**************************************************")
        continue_choice = input("Ingin melanjutkan perhitungan? (YA/TIDAK): ")


if __name__ == '__main__':
    main()